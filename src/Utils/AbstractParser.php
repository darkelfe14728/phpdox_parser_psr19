<?php

namespace phpDoxExtension\Parser\PSR19\Utils;

use TheSeer\phpDox\DocBlock\GenericParser;
use function array_key_exists;
use function mb_substr;

/**
 * The abstract parser used by all tags
 *
 * @package phpDoxExtension\Parser\PSR19\Utils
 */
abstract class AbstractParser extends GenericParser {
    /**
     * Is the tag allowed as inline tag "{@xxx}" ?
     *
     * @return bool True if allowed as inline tag
     */
    abstract public function allowedAsInline (): bool;

    /**
     * Parse the tag and return a corresponding element
     *
     * @return GenericElement The element generated by the parse
     */
    abstract protected function parse (): GenericElement;

    /**
     * Convenient function to create a new element
     *
     * @param string      $class          The element type (Fully Qualified Class Name)
     * @param bool        $allowInlineTag True if children must be scanned for "inline tags"
     * @param string|null $tagName        The element tag name (if not same that parser tag)
     *
     * @return GenericElement The new element
     */
    protected function createElement (string $class, bool $allowInlineTag, ?string $tagName = null): GenericElement {
        return new $class($this->factory, $tagName ?? $this->name, $allowInlineTag);
    }
    /**
     * Convenient function to create a new parser
     *
     * @param string      $class The parser type (Fully Qualified Class Name)
     * @param string|null $name  The parser name (if not, deduced for class name)
     *
     * @return GenericParser The new parser
     */
    protected function createParser (string $class, ?string $name = null): GenericParser {
        $realName = $name ?? mb_strtolower(preg_replace('@^\\\\?(?:.+\\\\)?([a-zA-Z0-9_]+?)(?:Parser)?$@', '$1', $class));

        /** @var GenericParser $parser */
        $parser = new $class($this->factory, $realName);
        $parser->aliasMap = $this->aliasMap;

        return $parser;
    }

    /**
     * The tag payload
     *
     * @return string|null The payload
     */
    protected function getPayload (): ?string {
        return $this->payload;
    }
    /**
     * The tag payload, splitted
     *
     * @param bool $keepEmpty Keep empty parts ?
     *
     * @return string[] List of payload parts
     */
    protected function getPayloadSplitted (bool $keepEmpty = false): array {
        return preg_split('@\s' . ($keepEmpty ? '' : '+') . '@', $this->getPayload());
    }

    /**
     * Complete a class name
     *
     * @param string $class_name The class name
     *
     * @return string The completed class name
     */
    protected function completeClassName (string $class_name): string {
        if (mb_substr($class_name, 0, 1) === '\\') {                             // If fully qualifed class name
            $class = $class_name;
        }
        elseif (array_key_exists($class_name, $this->aliasMap)) {                     // If imported ("use" keyword)
            $class = $this->aliasMap[$class_name];
        }
        elseif (array_key_exists('::context', $this->aliasMap)) {                   // There is an active namespace
            $class = $this->aliasMap['::context'] . '\\' . $class_name;
        }
        else {                                                                                  // Nothing special : assume global class
            $class = $class_name;
        }

        if (mb_substr($class, 0, 1) != '\\') {
            $class = '\\' . $class;
        }

        return $class;
    }

    /**
     * @inheritDoc
     */
    public function getObject (array $buffer): GenericElement {
        if (count($buffer)) {
            if (!empty($this->payload)) {
                $this->payload .= ' ';
            }
            $this->payload .= trim(implode("\n", array_map('trim', $buffer)));
        }

        return $this->parse();
    }
}