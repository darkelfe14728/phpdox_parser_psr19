<?php

namespace phpDoxExtension\Parser\PSR19\Utils;

use TheSeer\phpDox\DocBlock\GenericParser;

/**
 * The abstract parser used by all tags
 *
 * @package phpDoxExtension\Parser\PSR19\Utils
 */
abstract class AbstractParser extends GenericParser {
    /**
     * Is the tag allowed as inline tag "{@xxx}" ?
     *
     * @return bool True if allowed as inline tag
     */
    abstract public function allowedAsInline (): bool;

    /**
     * Parse the tag and return a corresponding element
     *
     * @return GenericElement The element generated by the parse
     */
    abstract protected function parse (): GenericElement;

    /**
     * Convenient function to create a new element
     *
     * @param string      $class          The element type (Fully Qualified Class Name)
     * @param bool        $allowInlineTag True if children must be scanned for "inline tags"
     * @param string|null $tagName        The element tag name (if not same that parser tag)
     *
     * @return GenericElement The new element
     */
    protected function createElement (string $class, bool $allowInlineTag, ?string $tagName = null): GenericElement {
        return new $class($this->factory, $tagName ?? $this->name, $allowInlineTag);
    }
    /**
     * Convenient function to create a new parser
     *
     * @param string      $class The parser type (Fully Qualified Class Name)
     * @param string|null $name  The parser name (if not, deduced for class name)
     *
     * @return GenericParser The new parser
     */
    protected function createParser (string $class, ?string $name = null): GenericParser {
        $realName = $name ?? mb_strtolower(preg_replace('@^\\\\?(?:.+\\\\)?([a-zA-Z0-9_]+?)(?:Parser)?$@', '$1', $class));

        /** @var GenericParser $parser */
        $parser = new $class($this->factory, $realName);
        $parser->aliasMap = $this->aliasMap;

        return $parser;
    }

    /**
     * The tag payload
     *
     * @return string|null The payload
     */
    protected function getPayload (): ?string {
        return $this->payload;
    }
    /**
     * The tag payload, splitted
     *
     * @param bool $keepEmpty Keep empty parts ?
     *
     * @return string[] List of payload parts
     */
    protected function getPayloadSplitted (bool $keepEmpty = false): array {
        return preg_split('@\s' . ($keepEmpty ? '' : '+') . '@', $this->getPayload());
    }

    /**
     * @inheritDoc
     */
    public function getObject (array $buffer): GenericElement {
        if (count($buffer)) {
            if (!empty($this->payload)) {
                $this->payload .= ' ';
            }
            $this->payload .= trim(implode("\n", array_map('trim', $buffer)));
        }

        return $this->parse();
    }
}